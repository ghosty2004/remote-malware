from websockets.legacy.client import connect
from json import loads, dumps
from win32api import GetUserName
from base64 import b64encode
from io import BytesIO
from ctypes import cast, POINTER
from comtypes import CLSCTX_ALL
from pycaw.pycaw import AudioUtilities, IAudioEndpointVolume
from pyaudio import PyAudio, paInt16
from audioop import rms
import asyncio
import threading
import subprocess
import pyautogui
import os
import fnmatch
import mimetypes

from enums import ScanTypes

server_uri = "ws://127.0.0.1:8080/"
interrupted = False
listen_to_microphone = False

class WebsocketManager:
    def __init__(self):
        self.event_handlers = {}
        self.connection_established = False
        self.websocket: connect

    async def connect_websocket(self):
        async with connect(server_uri) as websocket:
            self.websocket = websocket
            self.connection_established = True
            while True:
                event = await websocket.recv()
                event_data = loads(event)
                if event_data['eventName'] in self.event_handlers:
                    event_unique_id = event_data['uniqueId']
                    event_args = event_data['args']
                    event_type = event_data['type']
                    try:
                        event_handler = self.event_handlers[event_data['eventName']];
                        if(event_type == event_handler['type']):
                            if event_handler['type'] == "default":
                                await self.event_handlers[event_data['eventName']]['handler'](event_args)
                            elif event_handler['type'] == "proc":
                                value = await self.event_handlers[event_data['eventName']]['handler'](event_args)
                                await websocket.send(dumps({
                                    "eventName": "procReturn",
                                    "uniqueId": event_unique_id,
                                    "procValue": value
                                }))
                    except Exception as e:
                        print(f"Error while executing event handler {event_data['eventName']}: {e}")

    def listen_event(self):
        def decorator(func):
            self.event_handlers[func.__name__] = {
                "handler": func,
                "type": "default"
            }
            return func
        return decorator

    def listen_proc_event(self):
        def decorator(func):
            self.event_handlers[func.__name__] = {
                "handler": func,
                "type": "proc"
            }
            return func
        return decorator

    async def emit_remote_event(self, event_name: str, args: list = []):
        await self.websocket.send(dumps({
            "eventName": event_name,
            "args": args
        }))

websocket_manager = WebsocketManager()

@websocket_manager.listen_event()
async def shutdown(args: list):
    subprocess.run(['shutdown', '/s', '/f', '/t', '0'])

@websocket_manager.listen_event()
async def restart(args: list):
    subprocess.run(['shutdown', '/r', '/f', '/t', '0'])

@websocket_manager.listen_event()
async def set_volume(args: list):
    volume_level = args[0]
    devices = AudioUtilities.GetSpeakers()
    interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
    volume = cast(interface, POINTER(IAudioEndpointVolume))
    volume.SetMasterVolumeLevelScalar(volume_level, None)

@websocket_manager.listen_proc_event()
async def get_volume(args: list):
    devices = AudioUtilities.GetSpeakers()
    interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
    volume = cast(interface, POINTER(IAudioEndpointVolume))
    return volume.GetMasterVolumeLevelScalar() * 100

@websocket_manager.listen_proc_event()
async def get_name(args: list):
    return GetUserName();

@websocket_manager.listen_proc_event()
async def take_screenshot(args: list):
    screenshot = pyautogui.screenshot()
    image_bytes = BytesIO()
    screenshot.save(image_bytes, format='PNG')
    encoded_string = b64encode(image_bytes.getvalue())
    return encoded_string.decode()

@websocket_manager.listen_proc_event()
async def open_process(args: list):
    process = subprocess.Popen(args)
    return process.pid

@websocket_manager.listen_event()
async def kill_process(args: list):
    subprocess.run(['taskkill', '/F', '/PID', str(args[0])])

@websocket_manager.listen_event()
async def emulate_key_combination(args: list):
    key_list = str(args[0]).split('+')

    for key in key_list:
        key = key.strip()
        pyautogui.keyDown(key)

    for key in reversed(key_list):
        key = key.strip()
        pyautogui.keyUp(key)

@websocket_manager.listen_proc_event()
async def search_file(args: list):
    path: str = args[0]
    query: str = args[1]
    scan_type: int = args[2]

    found_files = []
    for root, dirs, files in os.walk(path):
        for file in files:
            if(((scan_type == ScanTypes.Full.value) or (scan_type == ScanTypes.Quick.value and root == path)) and fnmatch.fnmatch(file, query)):
                found_files.append(os.path.join(root, file))
    return found_files

@websocket_manager.listen_proc_event()
async def take_file(args: list):
    file_path: str = args[0]
    file = open(file_path, 'rb')
    encoded_string = b64encode(file.read())
    file.close()
    return {
        "fileName": os.path.basename(file_path),
        "fileMimeType": mimetypes.guess_type(file_path)[0],
        "fileBase64DecodedString": encoded_string.decode(),
    }

@websocket_manager.listen_proc_event()
async def take_files(args: list):
    root_path: str = args[0]
    found_files = []
    for root, dirs, files in os.walk(root_path):
        for file in files:
            file_path = os.path.join(root, file)
            file = open(file_path, 'rb')
            encoded_string = b64encode(file.read())
            file.close()
            found_files.append({
                "fileName": os.path.basename(file_path),
                "fileLocation": file_path,
                "fileMimeType": mimetypes.guess_type(file_path)[0],
                "fileBase64DecodedString": encoded_string.decode(),
            })
    return found_files

@websocket_manager.listen_event()
async def enable_microphone_listen(args: list):
    global listen_to_microphone

    if(not listen_to_microphone):
        listen_to_microphone = True
        
        audio = PyAudio()
        stream = audio.open(
            format=paInt16,
            channels=1,
            rate=48000,
            input=True,
            frames_per_buffer=2048,
        )

        while listen_to_microphone:
            audio_data = stream.read(2048)
            base64_chunk = b64encode(audio_data)
            await websocket_manager.emit_remote_event("microphone_listen_data", [base64_chunk.decode()])

@websocket_manager.listen_event()
async def disable_microphone_listen(args: list):
    global listen_to_microphone
    listen_to_microphone = False

@websocket_manager.listen_event()
async def init_microphone_listen(args: list):
    global listen_to_microphone_inited
    global listen_to_microphone

    if(not listen_to_microphone_inited):
        print('Init microphone listen successfully')
        listen_to_microphone_inited = True

        audio = PyAudio()
        stream = audio.open(
            format=paInt16,
            channels=1,
            rate=44100,
            input=True,
            frames_per_buffer=1024
        )

        while listen_to_microphone:
            print('Listening microphone data...')
            audio_data = stream.read(1024)
            energy = rms(audio_data, 2)
            if(energy > 2000):
                base64_data = b64encode(audio_data)
                await websocket_manager.emit_remote_event("microphone_listen_data", [base64_data.decode()])
                print('Sent microphone data')
            else:
                print('Microphone data not sent')
        else:
            print('Microphone listen disabled')
    else:
        print('Init microphone listen already inited')

async def init():
    await websocket_manager.connect_websocket()

async def main():
    print('Done')

async def run_tasks():
    init_task = asyncio.create_task(init())

    main_thread = threading.Thread(target=lambda: asyncio.run(main()))
    main_thread.start()

    await init_task
    main_thread.join()

try:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(run_tasks())
except KeyboardInterrupt:
    interrupted = True
    print("Exiting...")