from websockets.legacy.client import connect
from json import loads, dumps
from win32api import GetUserName
from base64 import b64encode
from io import BytesIO
from ctypes import cast, POINTER
from comtypes import CLSCTX_ALL
from pycaw.pycaw import AudioUtilities, IAudioEndpointVolume
from pyaudio import PyAudio, paInt16, paContinue
from concurrent.futures import ThreadPoolExecutor
import asyncio
import subprocess
import pyautogui
import os
import fnmatch
import mimetypes

from enums import ScanTypes

server_uri = "ws://127.0.0.1:8080/"

class WebsocketManager:
    def __init__(self):
        self.event_handlers = {}
        self.websocket: connect
        self.listen_to_microphone = False;
        self.audio = PyAudio()
        self.loop = asyncio.get_event_loop()

    async def connect_websocket(self):
        try:
            async with connect(server_uri) as websocket:
                print("Websocket connection established.")

                self.websocket = websocket

                while True:
                    event = await websocket.recv()
                    event_data = loads(event)
                    if event_data['eventName'] in self.event_handlers:
                        event_unique_id = event_data['uniqueId']
                        event_args = event_data['args']
                        event_type = event_data['type']
                        try:
                            event_handler = self.event_handlers[event_data['eventName']];
                            if(event_type == event_handler['type']):
                                if event_handler['type'] == "default":
                                    await self.event_handlers[event_data['eventName']]['handler'](event_args)
                                elif event_handler['type'] == "proc":
                                    value = await self.event_handlers[event_data['eventName']]['handler'](event_args)
                                    await websocket.send(dumps({
                                        "eventName": "procReturn",
                                        "uniqueId": event_unique_id,
                                        "procValue": value
                                    }))
                        except Exception as e:
                            print(f"Error while executing event handler {event_data['eventName']}: {e}")
        except Exception as e:
            print(f"Websocket connection error: {e}. Reconnecting...")
            await self.connect_websocket()

    def listen_event(self):
        def decorator(func):
            self.event_handlers[func.__name__] = {
                "handler": func,
                "type": "default"
            }
            return func
        return decorator

    def listen_proc_event(self):
        def decorator(func):
            self.event_handlers[func.__name__] = {
                "handler": func,
                "type": "proc"
            }
            return func
        return decorator

    async def emit_remote_event(self, event_name: str, args: list = []):
        await self.websocket.send(dumps({
            "eventName": event_name,
            "args": args
        }))

    def stream_callback(self, in_data, frame_count, time_info, status):
        if(self.listen_to_microphone):
            try:
                self.loop.run_until_complete(self.emit_remote_event("microphone_listen_data", [b64encode(in_data).decode()]))
            except:
                pass
        return (None, paContinue)

websocket_manager = WebsocketManager()

@websocket_manager.listen_event()
async def shutdown(args: list):
    subprocess.run(['shutdown', '/s', '/f', '/t', '0'])

@websocket_manager.listen_event()
async def restart(args: list):
    subprocess.run(['shutdown', '/r', '/f', '/t', '0'])

@websocket_manager.listen_event()
async def set_volume(args: list):
    volume_level = args[0]
    devices = AudioUtilities.GetSpeakers()
    interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
    volume = cast(interface, POINTER(IAudioEndpointVolume))
    volume.SetMasterVolumeLevelScalar(volume_level, None)

@websocket_manager.listen_proc_event()
async def get_volume(args: list):
    devices = AudioUtilities.GetSpeakers()
    interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
    volume = cast(interface, POINTER(IAudioEndpointVolume))
    return volume.GetMasterVolumeLevelScalar() * 100

@websocket_manager.listen_proc_event()
async def get_name(args: list):
    return GetUserName();

@websocket_manager.listen_proc_event()
async def take_screenshot(args: list):
    screenshot = pyautogui.screenshot()
    image_bytes = BytesIO()
    screenshot.save(image_bytes, format='PNG')
    encoded_string = b64encode(image_bytes.getvalue())
    return encoded_string.decode()

@websocket_manager.listen_proc_event()
async def open_process(args: list):
    process = subprocess.Popen(args)
    return process.pid

@websocket_manager.listen_event()
async def kill_process(args: list):
    subprocess.run(['taskkill', '/F', '/PID', str(args[0])])

@websocket_manager.listen_event()
async def emulate_key_combination(args: list):
    key_list = str(args[0]).split('+')

    for key in key_list:
        key = key.strip()
        pyautogui.keyDown(key)

    for key in reversed(key_list):
        key = key.strip()
        pyautogui.keyUp(key)

@websocket_manager.listen_proc_event()
async def search_file(args: list):
    path: str = args[0]
    query: str = args[1]
    scan_type: int = args[2]

    found_files = []
    for root, dirs, files in os.walk(path):
        for file in files:
            if(((scan_type == ScanTypes.Full.value) or (scan_type == ScanTypes.Quick.value and root == path)) and fnmatch.fnmatch(file, query)):
                found_files.append(os.path.join(root, file))
    return found_files

@websocket_manager.listen_proc_event()
async def take_file(args: list):
    file_path: str = args[0]
    file = open(file_path, 'rb')
    encoded_string = b64encode(file.read())
    file.close()
    return {
        "fileName": os.path.basename(file_path),
        "fileMimeType": mimetypes.guess_type(file_path)[0],
        "fileBase64DecodedString": encoded_string.decode(),
    }

@websocket_manager.listen_proc_event()
async def take_files(args: list):
    root_path: str = args[0]
    found_files = []
    for root, dirs, files in os.walk(root_path):
        for file in files:
            file_path = os.path.join(root, file)
            file = open(file_path, 'rb')
            encoded_string = b64encode(file.read())
            file.close()
            found_files.append({
                "fileName": os.path.basename(file_path),
                "fileLocation": file_path,
                "fileMimeType": mimetypes.guess_type(file_path)[0],
                "fileBase64DecodedString": encoded_string.decode(),
            })
    return found_files

@websocket_manager.listen_event()
async def enable_microphone_listen(args: list):
    websocket_manager.listen_to_microphone = True

@websocket_manager.listen_event()
async def disable_microphone_listen(args: list):
    websocket_manager.listen_to_microphone = False

def start_audio_stream():
    websocket_manager.audio.open(
        format=paInt16,
        channels=1,
        rate=48000,
        input=True,
        frames_per_buffer=2048,
        stream_callback=websocket_manager.stream_callback,
    )

try:
    executor = ThreadPoolExecutor(max_workers=1)
    executor.submit(start_audio_stream)

    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(websocket_manager.connect_websocket())
except KeyboardInterrupt:
    print("Exiting...")